webpackHotUpdate(0,{

/***/ 783:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar faker = __webpack_require__(784);\nvar validate = __webpack_require__(1745);\nvar moment = __webpack_require__(1747);\n\n/*=============================================================================\n\tSet some options for date validation\n=============================================================================*/\nvalidate.extend(validate.validators.datetime, {\n\tparse: function parse(value) {\n\t\treturn +moment.utc(value);\n\t},\n\tformat: function format(value, options) {\n\t\tvar format = options.dateOnly ? 'YYYY-MM-DD' : 'YYYY-MM-DD hh:mm:ss';\n\t\treturn moment.utc(value).format(format);\n\t}\n});\n\n/*=============================================================================\n\tAdd new validators\n=============================================================================*/\nvalidate.validators.boolean = function (value) {\n\tif (value !== false && value !== true) {\n\t\treturn 'must be true or false';\n\t}\n};\n\nvar ResourceUtils = function () {\n\tfunction ResourceUtils() {\n\t\t_classCallCheck(this, ResourceUtils);\n\t}\n\n\t_createClass(ResourceUtils, [{\n\t\tkey: 'generateResource',\n\n\t\t/*=============================================================================\n  \tGenerate a full resource (array of models)\n  \ttakes a description that defines what the resource looks like\n  \tincluding it's model and associated description\n  =============================================================================*/\n\t\tvalue: function generateResource(description, resources, isNestedResource) {\n\t\t\tif (resources) {\n\t\t\t\tthis.resources = resources;\n\t\t\t}\n\n\t\t\tif (description.type === 'array') {\n\t\t\t\tvar resource = [];\n\t\t\t\tfor (var i = 0, x = description.length; i < x; i++) {\n\t\t\t\t\tif (description.model) {\n\t\t\t\t\t\tvar model = this.generateModel(description.model);\n\t\t\t\t\t\tif (isNestedResource !== true) {\n\t\t\t\t\t\t\tmodel.id = i + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresource.push(model);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn resource;\n\t\t\t}\n\t\t\treturn this.generateModel(description.model);\n\t\t}\n\n\t\t/*=============================================================================\n  \tReturns a model object based on it's description\n  =============================================================================*/\n\n\t}, {\n\t\tkey: 'generateModel',\n\t\tvalue: function generateModel(description) {\n\t\t\tvar model = {};\n\n\t\t\tfor (var i = 0, x = description.length; i < x; i++) {\n\t\t\t\tvar key = description[i].key;\n\t\t\t\tmodel[key] = this.generatePropertyValue(description[i]);\n\t\t\t}\n\n\t\t\treturn model;\n\t\t}\n\n\t\t/*=============================================================================\n  \tReturns a value for a properties key (for instance first_name)\n  \tGet's passed in the property description and delegates to utility functions\n  \tbased on the properties type\n  =============================================================================*/\n\n\t}, {\n\t\tkey: 'generatePropertyValue',\n\t\tvalue: function generatePropertyValue(property) {\n\t\t\tif (property.type === 'random') {\n\t\t\t\treturn this.generateRandomValue(property);\n\t\t\t} else if (property.type === 'childResource') {\n\t\t\t\treturn this.generateValueFromAnotherResource(property);\n\t\t\t} else if (property.type === 'object') {\n\t\t\t\tif (property.resource && property.resource.type) {\n\t\t\t\t\treturn this.generateResource(property.resource, null, true);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t} else if (property.type === 'predefined') {\n\t\t\t\treturn property.predefinedValue;\n\t\t\t}\n\t\t}\n\n\t\t/*=============================================================================\n  \tReturns a random value given a properties description\n  \tUses faker.js (see docs for more info)\n  =============================================================================*/\n\n\t}, {\n\t\tkey: 'generateRandomValue',\n\t\tvalue: function generateRandomValue(property) {\n\t\t\tif (property.fakerCategory && property.fakerSubCategory) {\n\t\t\t\tvar args = [];\n\t\t\t\tif (property.fakerParams) {\n\t\t\t\t\tvar keys = Object.keys(property.fakerParams);\n\t\t\t\t\targs = keys.map(function (key) {\n\t\t\t\t\t\treturn property.fakerParams[key];\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn faker[property.fakerCategory][property.fakerSubCategory].apply(null, args);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t/*=============================================================================\n  \tCheck whether a child resource has a model key that requests it's parent i.e:\n  \t\tusers_model : [{\n  \t\ttype: 'childResource',\n  \t\tchildResourceName: 'comments'\n  \t}];\n  \tcomments_model: [{\n  \t\ttype: 'childResource',\n  \t\tchildResourceName: 'users'\n  \t}];\n  \t\tThe above will fail since it'll cause an infinite loop of generateResource\n  \tcalls.\n  =============================================================================*/\n\n\t}, {\n\t\tkey: 'doesChildResourceContainsRecursiveParent',\n\t\tvalue: function doesChildResourceContainsRecursiveParent(resourceName, childResource) {\n\t\t\tfor (var i = 0, x = childResource.model.length; i < x; i++) {\n\t\t\t\tif (childResource.model[i].type === 'childResource') {\n\t\t\t\t\tif (childResource.model[i].name === resourceName) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/*=============================================================================\n  \tGet a random sub-set of an array\n  =============================================================================*/\n\n\t}, {\n\t\tkey: 'getRandomSample',\n\t\tvalue: function getRandomSample(array, count) {\n\t\t\tvar indices = [];\n\t\t\tvar result = new Array(count);\n\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\tvar j = Math.floor(Math.random() * (array.length - i) + i);\n\t\t\t\tresult[i] = !array[indices[j] ? j : indices[j]];\n\t\t\t\tindices[j] = !indices[i] ? i : indices[i];\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/*=============================================================================\n  \tGenerate a key's value from another resource i.e. a post has an author\n  \twhere posts and users are resources\n  =============================================================================*/\n\n\t}, {\n\t\tkey: 'generateValueFromAnotherResource',\n\t\tvalue: function generateValueFromAnotherResource(property) {\n\t\t\tvar resourceDescription = void 0;\n\t\t\tfor (var i = 0, x = this.resources.length; i < x; i++) {\n\t\t\t\tif (this.resources[i].name === property.childResourceName) {\n\t\t\t\t\tresourceDescription = this.resources[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (resourceDescription) {\n\t\t\t\tvar childResourceContainsRecursiveParent = this.doesChildResourceContainsRecursiveParent(property.childResourceName, resourceDescription);\n\t\t\t\tif (childResourceContainsRecursiveParent) {\n\t\t\t\t\treturn 'ERROR, ' + property.childResourceName + ' is a recursive key';\n\t\t\t\t}\n\t\t\t\t// Refactor this line below so it doesn't generate the resource\n\t\t\t\t// but is the prevously-generated resource.\n\t\t\t\tvar resource = this.generateResource(resourceDescription);\n\n\t\t\t\tif (property.childResourceMethod === 'array') {\n\t\t\t\t\tif (property.childResourceLimit) {\n\t\t\t\t\t\tvar limit = parseFloat(property.childResourceLimit);\n\t\t\t\t\t\tif (limit > resource.length) {\n\t\t\t\t\t\t\treturn resource;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this.getRandomSample(resource, limit);\n\t\t\t\t\t}\n\t\t\t\t\treturn resource;\n\t\t\t\t} else if (property.childResourceMethod === 'object') {\n\t\t\t\t\treturn resource[Math.floor(Math.random() * resource.length)];\n\t\t\t\t} else if (property.childResourceMethod === 'id') {\n\t\t\t\t\treturn resource[Math.floor(Math.random() * resource.length)].id;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*=============================================================================\n  \tReturns a full database object from the descriptions stored in the\n  \tadmin DB\n  =============================================================================*/\n\n\t}, {\n\t\tkey: 'generateDatabase',\n\t\tvalue: function generateDatabase(resources) {\n\t\t\tthis.resources = resources;\n\t\t\tvar database = {};\n\n\t\t\tfor (var i = 0, x = resources.length; i < x; i++) {\n\t\t\t\tvar resource = resources[i];\n\t\t\t\tdatabase[resource.name] = this.generateResource(resource);\n\t\t\t}\n\n\t\t\treturn database;\n\t\t}\n\n\t\t/*=============================================================================\n  \tValidates a POST or PUT request against the model description if the key\n  \tis a required parameter.\n  =============================================================================*/\n\n\t}, {\n\t\tkey: 'validateRequest',\n\t\tvalue: function validateRequest(resource, request) {\n\t\t\treturn validate(request, resource.validationConfig);\n\t\t}\n\n\t\t/*=============================================================================\n  \tGenerate validation config (for validate.js) for a resource\n  =============================================================================*/\n\n\t}, {\n\t\tkey: 'generateValidationConfigForResource',\n\t\tvalue: function generateValidationConfigForResource(resource) {\n\t\t\tvar _this = this;\n\n\t\t\tvar validationConfig = {};\n\n\t\t\t// Generate a validate.js configuraton from the model description\n\t\t\tresource.model.map(function (parameter) {\n\t\t\t\tif (parameter.type === 'childResource') {\n\t\t\t\t\t// Handle a nested resource and validate it\n\t\t\t\t} else if (parameter.type === 'object') {\n\t\t\t\t\t// Handle a nested object / array and validate it\n\t\t\t\t} else {\n\t\t\t\t\tvalidationConfig[parameter.key] = _this.getSingleRequestParameterValidationRequirements(parameter);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn validationConfig;\n\t\t}\n\n\t\t/*=============================================================================\n  \tGenerate the validate.js requirements for a single model.\n  =============================================================================*/\n\n\t}, {\n\t\tkey: 'getSingleRequestParameterValidationRequirements',\n\t\tvalue: function getSingleRequestParameterValidationRequirements(parameter) {\n\t\t\tvar config = {};\n\n\t\t\tif (parameter.required) {\n\t\t\t\tconfig.presence = true;\n\t\t\t}\n\n\t\t\tif (parameter.type === 'predefined') {\n\t\t\t\t// Handle predefined values\n\t\t\t} else if (parameter.type === 'random') {\n\t\t\t\tvar exampleValue = this.generateRandomValue(parameter);\n\t\t\t\tvar isBoolean = typeof exampleValue === 'boolean';\n\t\t\t\tvar isString = typeof exampleValue === 'string';\n\n\t\t\t\t// Date validation (range)\n\t\t\t\tif (parameter.fakerCategory === 'date') {\n\t\t\t\t\tvar dateType = parameter.fakerSubCategory;\n\t\t\t\t\tvar fakerParams = parameter.fakerParams;\n\t\t\t\t\tif (dateType === 'between') {\n\t\t\t\t\t\tconfig.datetime = {};\n\t\t\t\t\t\tif (fakerParams.from) {\n\t\t\t\t\t\t\tconfig.datetime.earliest = fakerParams.from;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (fakerParams.to) {\n\t\t\t\t\t\t\tconfig.datetime.latest = fakerParams.to;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (dateType === 'future') {\n\t\t\t\t\t\tconfig.datetime = {};\n\t\t\t\t\t\tif (fakerParams.refDate) {\n\t\t\t\t\t\t\tconfig.datetime.earliest = fakerParams.refDate;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (fakerParams.years) {\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// NOTE: Refactor this so it works when this is run so it's always looking at todays date\n\t\t\t\t\t\t\t// Consider storing latest as the string 'today' and checking for that string when\n\t\t\t\t\t\t\t// validation is run\n\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\tvar refDate = fakerParams.refDate || new Date();\n\t\t\t\t\t\t\tconfig.datetime.latest = moment(refDate).add(fakerParams.years, 'years').format('YYYY-MM-DD');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (dateType === 'past') {\n\t\t\t\t\t\tconfig.datetime = {};\n\t\t\t\t\t\tif (fakerParams.refDate) {\n\t\t\t\t\t\t\tconfig.datetime.latest = fakerParams.refDate;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (fakerParams.years) {\n\t\t\t\t\t\t\tconfig.datetime.earliest = moment(fakerParams.refDate).subtract(fakerParams.years, 'years').format('YYYY-MM-DD');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (dateType === 'month') {\n\t\t\t\t\t\tif (parameter.fakerSubCategory === 'month') {\n\t\t\t\t\t\t\tconfig.inclusion = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'November', 'December'];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Else it's just a random date, no min or max needed\n\t\t\t\t\t\tconfig.datetime = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (parameter.fakerSubCategory === 'email') {\n\t\t\t\t\tconfig.email = true;\n\t\t\t\t} else if (parameter.fakerSubCategory === 'url') {\n\t\t\t\t\tconfig.url = true;\n\t\t\t\t} else if (isString && parameter.fakerSubCategory === 'arrayElement') {\n\t\t\t\t\t// We have to check if array is an array of strings since validate.js doesn't support\n\t\t\t\t\t// nested objects. TODO: write a validator that supports deepEqual of nested objects.\n\t\t\t\t\tconfig.inclusion = parameter.fakerParams.json;\n\t\t\t\t} else if (isBoolean) {\n\t\t\t\t\tconfig.boolean = true;\n\t\t\t\t} else if (parameter.fakerSubCategory === 'number') {\n\t\t\t\t\tconfig.numericality = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn config;\n\t\t}\n\t}]);\n\n\treturn ResourceUtils;\n}();\n\nmodule.exports = new ResourceUtils();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9iYWNrZW5kL1Jlc291cmNlVXRpbHMuanM/MWQyYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBQ0EsSUFBTSxRQUFRLG9CQUFRLEdBQVIsQ0FBZDtBQUNBLElBQU0sV0FBVyxvQkFBUSxJQUFSLENBQWpCO0FBQ0EsSUFBTSxTQUFTLG9CQUFRLElBQVIsQ0FBZjs7Ozs7QUFLQSxTQUFTLE1BQVQsQ0FBZ0IsU0FBUyxVQUFULENBQW9CLFFBQXBDLEVBQThDO0FBQzVDLFFBQU8sZUFBVSxLQUFWLEVBQWlCO0FBQ3RCLFNBQU8sQ0FBQyxPQUFPLEdBQVAsQ0FBVyxLQUFYLENBQVI7QUFDRCxFQUgyQztBQUk1QyxTQUFRLGdCQUFVLEtBQVYsRUFBaUIsT0FBakIsRUFBMEI7QUFDaEMsTUFBSSxTQUFTLFFBQVEsUUFBUixHQUFtQixZQUFuQixHQUFrQyxxQkFBL0M7QUFDQSxTQUFPLE9BQU8sR0FBUCxDQUFXLEtBQVgsRUFBa0IsTUFBbEIsQ0FBeUIsTUFBekIsQ0FBUDtBQUNEO0FBUDJDLENBQTlDOzs7OztBQWFBLFNBQVMsVUFBVCxDQUFvQixPQUFwQixHQUE4QixVQUFVLEtBQVYsRUFBaUI7QUFDOUMsS0FBSSxVQUFVLEtBQVYsSUFBbUIsVUFBVSxJQUFqQyxFQUF1QztBQUN0QyxTQUFPLHVCQUFQO0FBQ0E7QUFDRCxDQUpEOztJQU1NLGE7Ozs7Ozs7Ozs7Ozs7bUNBTVksVyxFQUFhLFMsRUFBVyxnQixFQUFrQjtBQUMxRCxPQUFJLFNBQUosRUFBZTtBQUNkLFNBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNBOztBQUVELE9BQUksWUFBWSxJQUFaLEtBQXFCLE9BQXpCLEVBQWtDO0FBQ2pDLFFBQUksV0FBVyxFQUFmO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBUixFQUFXLElBQUksWUFBWSxNQUFoQyxFQUF3QyxJQUFJLENBQTVDLEVBQStDLEdBQS9DLEVBQW9EO0FBQ25ELFNBQUksWUFBWSxLQUFoQixFQUF1QjtBQUN0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TyxPQUFQLEdBQWlCLElBQWpCO0FBQ0EsS0FGTSxNQUVBLElBQUksVUFBVSxnQkFBVixLQUErQixRQUFuQyxFQUE2QztBQUNuRCxZQUFPLFlBQVAsR0FBc0IsSUFBdEI7QUFDQTtBQUNEOztBQUVELFVBQU8sTUFBUDtBQUNBOzs7Ozs7QUFHRixPQUFPLE9BQVAsR0FBaUIsSUFBSSxhQUFKLEVBQWpCIiwiZmlsZSI6Ijc4My5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGZha2VyID0gcmVxdWlyZSgnZmFrZXInKTtcbmNvbnN0IHZhbGlkYXRlID0gcmVxdWlyZSgndmFsaWRhdGUuanMnKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFNldCBzb21lIG9wdGlvbnMgZm9yIGRhdGUgdmFsaWRhdGlvblxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xudmFsaWRhdGUuZXh0ZW5kKHZhbGlkYXRlLnZhbGlkYXRvcnMuZGF0ZXRpbWUsIHtcbiAgcGFyc2U6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiArbW9tZW50LnV0Yyh2YWx1ZSk7XG4gIH0sXG4gIGZvcm1hdDogZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgbGV0IGZvcm1hdCA9IG9wdGlvbnMuZGF0ZU9ubHkgPyAnWVlZWS1NTS1ERCcgOiAnWVlZWS1NTS1ERCBoaDptbTpzcyc7XG4gICAgcmV0dXJuIG1vbWVudC51dGModmFsdWUpLmZvcm1hdChmb3JtYXQpO1xuICB9XG59KTtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRBZGQgbmV3IHZhbGlkYXRvcnNcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbnZhbGlkYXRlLnZhbGlkYXRvcnMuYm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAodmFsdWUgIT09IGZhbHNlICYmIHZhbHVlICE9PSB0cnVlKSB7XG5cdFx0cmV0dXJuICdtdXN0IGJlIHRydWUgb3IgZmFsc2UnO1xuXHR9XG59O1xuXG5jbGFzcyBSZXNvdXJjZVV0aWxzIHtcblx0Lyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdEdlbmVyYXRlIGEgZnVsbCByZXNvdXJjZSAoYXJyYXkgb2YgbW9kZWxzKVxuXHRcdHRha2VzIGEgZGVzY3JpcHRpb24gdGhhdCBkZWZpbmVzIHdoYXQgdGhlIHJlc291cmNlIGxvb2tzIGxpa2Vcblx0XHRpbmNsdWRpbmcgaXQncyBtb2RlbCBhbmQgYXNzb2NpYXRlZCBkZXNjcmlwdGlvblxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cdGdlbmVyYXRlUmVzb3VyY2UoZGVzY3JpcHRpb24sIHJlc291cmNlcywgaXNOZXN0ZWRSZXNvdXJjZSkge1xuXHRcdGlmIChyZXNvdXJjZXMpIHtcblx0XHRcdHRoaXMucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xuXHRcdH1cblxuXHRcdGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnYXJyYXknKSB7XG5cdFx0XHRsZXQgcmVzb3VyY2UgPSBbXTtcblx0XHRcdGZvciAobGV0IGkgPSAwLCB4ID0gZGVzY3JpcHRpb24ubGVuZ3RoOyBpIDwgeDsgaSsrKSB7XG5cdFx0XHRcdGlmIChkZXNjcmlwdGlvbi5tb2RlbCkge1xuXHRcdFx0XHRcdGxldCBtb2RlbCA9IHRoaXMuZ2VuZXJhdGVNb2RlbChkZXNjcmlwdGlvbi5tb2RlbCk7XG5cdFx0XHRcdFx0aWYgKGlzTmVzdGVkUmVzb3VyY2UgIT09IHRydWUpIHtcblx0XHRcdFx0XHRcdG1vZGVsLmlkID0gaSArIDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc291cmNlLnB1c2gobW9kZWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXNvdXJjZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVNb2RlbChkZXNjcmlwdGlvbi5tb2RlbCk7XG5cdH1cblxuXHQvKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0UmV0dXJucyBhIG1vZGVsIG9iamVjdCBiYXNlZCBvbiBpdCdzIGRlc2NyaXB0aW9uXG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblx0Z2VuZXJhdGVNb2RlbChkZXNjcmlwdGlvbikge1xuXHRcdGxldCBtb2RlbCA9IHt9O1xuXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHggPSBkZXNjcmlwdGlvbi5sZW5ndGg7IGkgPCB4OyBpKyspIHtcblx0XHRcdGxldCBrZXkgPSBkZXNjcmlwdGlvbltpXS5rZXk7XG5cdFx0XHRtb2RlbFtrZXldID0gdGhpcy5nZW5lcmF0ZVByb3BlcnR5VmFsdWUoZGVzY3JpcHRpb25baV0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBtb2RlbDtcblx0fVxuXG5cdC8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHRSZXR1cm5zIGEgdmFsdWUgZm9yIGEgcHJvcGVydGllcyBrZXkgKGZvciBpbnN0YW5jZSBmaXJzdF9uYW1lKVxuXHRcdEdldCdzIHBhc3NlZCBpbiB0aGUgcHJvcGVydHkgZGVzY3JpcHRpb24gYW5kIGRlbGVnYXRlcyB0byB1dGlsaXR5IGZ1bmN0aW9uc1xuXHRcdGJhc2VkIG9uIHRoZSBwcm9wZXJ0aWVzIHR5cGVcblx0PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXHRnZW5lcmF0ZVByb3BlcnR5VmFsdWUocHJvcGVydHkpIHtcblx0XHRpZiAocHJvcGVydHkudHlwZSA9PT0gJ3JhbmRvbScpIHtcblx0XHRcdHJldHVybiB0aGlzLmdlbmVyYXRlUmFuZG9tVmFsdWUocHJvcGVydHkpO1xuXHRcdH0gZWxzZSBpZiAocHJvcGVydHkudHlwZSA9PT0gJ2NoaWxkUmVzb3VyY2UnKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZVZhbHVlRnJvbUFub3RoZXJSZXNvdXJjZShwcm9wZXJ0eSk7XG5cdFx0fSBlbHNlIGlmIChwcm9wZXJ0eS50eXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0aWYgKHByb3BlcnR5LnJlc291cmNlICYmIHByb3BlcnR5LnJlc291cmNlLnR5cGUpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVSZXNvdXJjZShwcm9wZXJ0eS5yZXNvdXJjZSwgbnVsbCwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2UgaWYgKHByb3BlcnR5LnR5cGUgPT09ICdwcmVkZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIHByb3BlcnR5LnByZWRlZmluZWRWYWx1ZTtcblx0XHR9XG5cdH1cblxuXHQvKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0UmV0dXJucyBhIHJhbmRvbSB2YWx1ZSBnaXZlbiBhIHByb3BlcnRpZXMgZGVzY3JpcHRpb25cblx0XHRVc2VzIGZha2VyLmpzIChzZWUgZG9jcyBmb3IgbW9yZSBpbmZvKVxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cdGdlbmVyYXRlUmFuZG9tVmFsdWUocHJvcGVydHkpIHtcblx0XHRpZiAocHJvcGVydHkuZmFrZXJDYXRlZ29yeSAmJiBwcm9wZXJ0eS5mYWtlclN1YkNhdGVnb3J5KSB7XG5cdFx0XHRsZXQgYXJncyA9IFtdO1xuXHRcdFx0aWYgKHByb3BlcnR5LmZha2VyUGFyYW1zKSB7XG5cdFx0XHRcdGxldCBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydHkuZmFrZXJQYXJhbXMpO1xuXHRcdFx0XHRhcmdzID0ga2V5cy5tYXAoKGtleSkgPT4gcHJvcGVydHkuZmFrZXJQYXJhbXNba2V5XSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFrZXJbcHJvcGVydHkuZmFrZXJDYXRlZ29yeV1bcHJvcGVydHkuZmFrZXJTdWJDYXRlZ29yeV0uYXBwbHkobnVsbCwgYXJncyk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Lyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdENoZWNrIHdoZXRoZXIgYSBjaGlsZCByZXNvdXJjZSBoYXMgYSBtb2RlbCBrZXkgdGhhdCByZXF1ZXN0cyBpdCdzIHBhcmVudCBpLmU6XG5cblx0XHR1c2Vyc19tb2RlbCA6IFt7XG5cdFx0XHR0eXBlOiAnY2hpbGRSZXNvdXJjZScsXG5cdFx0XHRjaGlsZFJlc291cmNlTmFtZTogJ2NvbW1lbnRzJ1xuXHRcdH1dO1xuXHRcdGNvbW1lbnRzX21vZGVsOiBbe1xuXHRcdFx0dHlwZTogJ2NoaWxkUmVzb3VyY2UnLFxuXHRcdFx0Y2hpbGRSZXNvdXJjZU5hbWU6ICd1c2Vycydcblx0XHR9XTtcblxuXHRcdFRoZSBhYm92ZSB3aWxsIGZhaWwgc2luY2UgaXQnbGwgY2F1c2UgYW4gaW5maW5pdGUgbG9vcCBvZiBnZW5lcmF0ZVJlc291cmNlXG5cdFx0Y2FsbHMuXG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblx0ZG9lc0NoaWxkUmVzb3VyY2VDb250YWluc1JlY3Vyc2l2ZVBhcmVudChyZXNvdXJjZU5hbWUsIGNoaWxkUmVzb3VyY2UpIHtcblx0XHRmb3IgKGxldCBpID0gMCwgeCA9IGNoaWxkUmVzb3VyY2UubW9kZWwubGVuZ3RoOyBpIDwgeDsgaSsrKSB7XG5cdFx0XHRpZiAoY2hpbGRSZXNvdXJjZS5tb2RlbFtpXS50eXBlID09PSAnY2hpbGRSZXNvdXJjZScpIHtcblx0XHRcdFx0aWYgKGNoaWxkUmVzb3VyY2UubW9kZWxbaV0ubmFtZSA9PT0gcmVzb3VyY2VOYW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Lyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdEdldCBhIHJhbmRvbSBzdWItc2V0IG9mIGFuIGFycmF5XG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblx0Z2V0UmFuZG9tU2FtcGxlKGFycmF5LCBjb3VudCkge1xuICAgIGxldCBpbmRpY2VzID0gW107XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBsZXQgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChhcnJheS5sZW5ndGggLSBpKSArIGkpO1xuICAgICAgcmVzdWx0W2ldID0gIWFycmF5W2luZGljZXNbal0gPyBqIDogaW5kaWNlc1tqXV07XG4gICAgICBpbmRpY2VzW2pdID0gIWluZGljZXNbaV0gPyBpIDogaW5kaWNlc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHRHZW5lcmF0ZSBhIGtleSdzIHZhbHVlIGZyb20gYW5vdGhlciByZXNvdXJjZSBpLmUuIGEgcG9zdCBoYXMgYW4gYXV0aG9yXG5cdFx0d2hlcmUgcG9zdHMgYW5kIHVzZXJzIGFyZSByZXNvdXJjZXNcblx0PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXHRnZW5lcmF0ZVZhbHVlRnJvbUFub3RoZXJSZXNvdXJjZShwcm9wZXJ0eSkge1xuXHRcdGxldCByZXNvdXJjZURlc2NyaXB0aW9uO1xuXHRcdGZvciAobGV0IGkgPSAwLCB4ID0gdGhpcy5yZXNvdXJjZXMubGVuZ3RoOyBpIDwgeDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5yZXNvdXJjZXNbaV0ubmFtZSA9PT0gcHJvcGVydHkuY2hpbGRSZXNvdXJjZU5hbWUpIHtcblx0XHRcdFx0cmVzb3VyY2VEZXNjcmlwdGlvbiA9IHRoaXMucmVzb3VyY2VzW2ldO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocmVzb3VyY2VEZXNjcmlwdGlvbikge1xuXHRcdFx0bGV0IGNoaWxkUmVzb3VyY2VDb250YWluc1JlY3Vyc2l2ZVBhcmVudCA9IHRoaXMuZG9lc0NoaWxkUmVzb3VyY2VDb250YWluc1JlY3Vyc2l2ZVBhcmVudChwcm9wZXJ0eS5jaGlsZFJlc291cmNlTmFtZSwgcmVzb3VyY2VEZXNjcmlwdGlvbik7XG5cdFx0XHRpZiAoY2hpbGRSZXNvdXJjZUNvbnRhaW5zUmVjdXJzaXZlUGFyZW50KSB7XG5cdFx0XHRcdHJldHVybiAnRVJST1IsICcgKyBwcm9wZXJ0eS5jaGlsZFJlc291cmNlTmFtZSArICcgaXMgYSByZWN1cnNpdmUga2V5Jztcblx0XHRcdH1cblx0XHRcdC8vIFJlZmFjdG9yIHRoaXMgbGluZSBiZWxvdyBzbyBpdCBkb2Vzbid0IGdlbmVyYXRlIHRoZSByZXNvdXJjZVxuXHRcdFx0Ly8gYnV0IGlzIHRoZSBwcmV2b3VzbHktZ2VuZXJhdGVkIHJlc291cmNlLlxuXHRcdFx0bGV0IHJlc291cmNlID0gdGhpcy5nZW5lcmF0ZVJlc291cmNlKHJlc291cmNlRGVzY3JpcHRpb24pO1xuXG5cdFx0XHRpZiAocHJvcGVydHkuY2hpbGRSZXNvdXJjZU1ldGhvZCA9PT0gJ2FycmF5Jykge1xuXHRcdFx0XHRpZiAocHJvcGVydHkuY2hpbGRSZXNvdXJjZUxpbWl0KSB7XG5cdFx0XHRcdFx0bGV0IGxpbWl0ID0gcGFyc2VGbG9hdChwcm9wZXJ0eS5jaGlsZFJlc291cmNlTGltaXQpO1xuXHRcdFx0XHRcdGlmIChsaW1pdCA+IHJlc291cmNlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc291cmNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRSYW5kb21TYW1wbGUocmVzb3VyY2UsIGxpbWl0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVzb3VyY2U7XG5cdFx0XHR9IGVsc2UgaWYgKHByb3BlcnR5LmNoaWxkUmVzb3VyY2VNZXRob2QgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHJldHVybiByZXNvdXJjZVtNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogcmVzb3VyY2UubGVuZ3RoKSldO1xuXHRcdFx0fSBlbHNlIGlmIChwcm9wZXJ0eS5jaGlsZFJlc291cmNlTWV0aG9kID09PSAnaWQnKSB7XG5cdFx0XHRcdHJldHVybiByZXNvdXJjZVtNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogcmVzb3VyY2UubGVuZ3RoKSldLmlkO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XHRSZXR1cm5zIGEgZnVsbCBkYXRhYmFzZSBvYmplY3QgZnJvbSB0aGUgZGVzY3JpcHRpb25zIHN0b3JlZCBpbiB0aGVcblx0XHRhZG1pbiBEQlxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cdGdlbmVyYXRlRGF0YWJhc2UocmVzb3VyY2VzKSB7XG5cdFx0dGhpcy5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XG5cdFx0bGV0IGRhdGFiYXNlID0ge307XG5cblx0XHRmb3IgKGxldCBpID0gMCwgeCA9IHJlc291cmNlcy5sZW5ndGg7IGkgPCB4OyBpKyspIHtcblx0XHRcdGxldCByZXNvdXJjZSA9IHJlc291cmNlc1tpXTtcblx0XHRcdGRhdGFiYXNlW3Jlc291cmNlLm5hbWVdID0gdGhpcy5nZW5lcmF0ZVJlc291cmNlKHJlc291cmNlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YWJhc2U7XG5cdH1cblxuXHQvKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0VmFsaWRhdGVzIGEgUE9TVCBvciBQVVQgcmVxdWVzdCBhZ2FpbnN0IHRoZSBtb2RlbCBkZXNjcmlwdGlvbiBpZiB0aGUga2V5XG5cdFx0aXMgYSByZXF1aXJlZCBwYXJhbWV0ZXIuXG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblx0dmFsaWRhdGVSZXF1ZXN0KHJlc291cmNlLCByZXF1ZXN0KSB7XG5cdFx0cmV0dXJuIHZhbGlkYXRlKHJlcXVlc3QsIHJlc291cmNlLnZhbGlkYXRpb25Db25maWcpO1xuXHR9XG5cblx0Lyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdEdlbmVyYXRlIHZhbGlkYXRpb24gY29uZmlnIChmb3IgdmFsaWRhdGUuanMpIGZvciBhIHJlc291cmNlXG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblx0Z2VuZXJhdGVWYWxpZGF0aW9uQ29uZmlnRm9yUmVzb3VyY2UocmVzb3VyY2UpIHtcblx0XHRsZXQgdmFsaWRhdGlvbkNvbmZpZyA9IHt9O1xuXG5cdFx0Ly8gR2VuZXJhdGUgYSB2YWxpZGF0ZS5qcyBjb25maWd1cmF0b24gZnJvbSB0aGUgbW9kZWwgZGVzY3JpcHRpb25cblx0XHRyZXNvdXJjZS5tb2RlbC5tYXAoKHBhcmFtZXRlcikgPT4ge1xuXHRcdFx0aWYgKHBhcmFtZXRlci50eXBlID09PSAnY2hpbGRSZXNvdXJjZScpIHtcblx0XHRcdFx0Ly8gSGFuZGxlIGEgbmVzdGVkIHJlc291cmNlIGFuZCB2YWxpZGF0ZSBpdFxuXHRcdFx0fSBlbHNlIGlmIChwYXJhbWV0ZXIudHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Ly8gSGFuZGxlIGEgbmVzdGVkIG9iamVjdCAvIGFycmF5IGFuZCB2YWxpZGF0ZSBpdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsaWRhdGlvbkNvbmZpZ1twYXJhbWV0ZXIua2V5XSA9IHRoaXMuZ2V0U2luZ2xlUmVxdWVzdFBhcmFtZXRlclZhbGlkYXRpb25SZXF1aXJlbWVudHMocGFyYW1ldGVyKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiB2YWxpZGF0aW9uQ29uZmlnO1xuXHR9XG5cblx0Lyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdEdlbmVyYXRlIHRoZSB2YWxpZGF0ZS5qcyByZXF1aXJlbWVudHMgZm9yIGEgc2luZ2xlIG1vZGVsLlxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cdGdldFNpbmdsZVJlcXVlc3RQYXJhbWV0ZXJWYWxpZGF0aW9uUmVxdWlyZW1lbnRzKHBhcmFtZXRlcikge1xuXHRcdGxldCBjb25maWcgPSB7fTtcblxuXHRcdGlmIChwYXJhbWV0ZXIucmVxdWlyZWQpIHtcblx0XHRcdGNvbmZpZy5wcmVzZW5jZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKHBhcmFtZXRlci50eXBlID09PSAncHJlZGVmaW5lZCcpIHtcblx0XHRcdC8vIEhhbmRsZSBwcmVkZWZpbmVkIHZhbHVlc1xuXHRcdH0gZWxzZSBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdyYW5kb20nKSB7XG5cdFx0XHRsZXQgZXhhbXBsZVZhbHVlID0gdGhpcy5nZW5lcmF0ZVJhbmRvbVZhbHVlKHBhcmFtZXRlcik7XG5cdFx0XHRsZXQgaXNCb29sZWFuID0gdHlwZW9mIChleGFtcGxlVmFsdWUpID09PSAnYm9vbGVhbic7XG5cdFx0XHRsZXQgaXNTdHJpbmcgPSB0eXBlb2YgKGV4YW1wbGVWYWx1ZSkgPT09ICdzdHJpbmcnO1xuXG5cdFx0XHQvLyBEYXRlIHZhbGlkYXRpb24gKHJhbmdlKVxuXHRcdFx0aWYgKHBhcmFtZXRlci5mYWtlckNhdGVnb3J5ID09PSAnZGF0ZScpIHtcblx0XHRcdFx0bGV0IGRhdGVUeXBlID0gcGFyYW1ldGVyLmZha2VyU3ViQ2F0ZWdvcnk7XG5cdFx0XHRcdGxldCBmYWtlclBhcmFtcyA9IHBhcmFtZXRlci5mYWtlclBhcmFtcztcblx0XHRcdFx0aWYgKGRhdGVUeXBlID09PSAnYmV0d2VlbicpIHtcblx0XHRcdFx0XHRjb25maWcuZGF0ZXRpbWUgPSB7fTtcblx0XHRcdFx0XHRpZiAoZmFrZXJQYXJhbXMuZnJvbSkge1xuXHRcdFx0XHRcdFx0Y29uZmlnLmRhdGV0aW1lLmVhcmxpZXN0ID0gZmFrZXJQYXJhbXMuZnJvbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGZha2VyUGFyYW1zLnRvKSB7XG5cdFx0XHRcdFx0XHRjb25maWcuZGF0ZXRpbWUubGF0ZXN0ID0gZmFrZXJQYXJhbXMudG87XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGRhdGVUeXBlID09PSAnZnV0dXJlJykge1xuXHRcdFx0XHRcdGNvbmZpZy5kYXRldGltZSA9IHt9O1xuXHRcdFx0XHRcdGlmIChmYWtlclBhcmFtcy5yZWZEYXRlKSB7XG5cdFx0XHRcdFx0XHRjb25maWcuZGF0ZXRpbWUuZWFybGllc3QgPSBmYWtlclBhcmFtcy5yZWZEYXRlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZmFrZXJQYXJhbXMueWVhcnMpIHtcblx0XHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0XHQvLyBOT1RFOiBSZWZhY3RvciB0aGlzIHNvIGl0IHdvcmtzIHdoZW4gdGhpcyBpcyBydW4gc28gaXQncyBhbHdheXMgbG9va2luZyBhdCB0b2RheXMgZGF0ZVxuXHRcdFx0XHRcdFx0Ly8gQ29uc2lkZXIgc3RvcmluZyBsYXRlc3QgYXMgdGhlIHN0cmluZyAndG9kYXknIGFuZCBjaGVja2luZyBmb3IgdGhhdCBzdHJpbmcgd2hlblxuXHRcdFx0XHRcdFx0Ly8gdmFsaWRhdGlvbiBpcyBydW5cblx0XHRcdFx0XHRcdC8vXG5cblx0XHRcdFx0XHRcdGxldCByZWZEYXRlID0gZmFrZXJQYXJhbXMucmVmRGF0ZSB8fCBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRcdFx0Y29uZmlnLmRhdGV0aW1lLmxhdGVzdCA9IG1vbWVudChyZWZEYXRlKS5hZGQoZmFrZXJQYXJhbXMueWVhcnMsICd5ZWFycycpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChkYXRlVHlwZSA9PT0gJ3Bhc3QnKSB7XG5cdFx0XHRcdFx0Y29uZmlnLmRhdGV0aW1lID0ge307XG5cdFx0XHRcdFx0aWYgKGZha2VyUGFyYW1zLnJlZkRhdGUpIHtcblx0XHRcdFx0XHRcdGNvbmZpZy5kYXRldGltZS5sYXRlc3QgPSBmYWtlclBhcmFtcy5yZWZEYXRlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZmFrZXJQYXJhbXMueWVhcnMpIHtcblx0XHRcdFx0XHRcdGNvbmZpZy5kYXRldGltZS5lYXJsaWVzdCA9IG1vbWVudChmYWtlclBhcmFtcy5yZWZEYXRlKS5zdWJ0cmFjdChmYWtlclBhcmFtcy55ZWFycywgJ3llYXJzJykuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGRhdGVUeXBlID09PSAnbW9udGgnKSB7XG5cdFx0XHRcdFx0aWYgKHBhcmFtZXRlci5mYWtlclN1YkNhdGVnb3J5ID09PSAnbW9udGgnKSB7XG5cdFx0XHRcdFx0XHRjb25maWcuaW5jbHVzaW9uID0gWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBFbHNlIGl0J3MganVzdCBhIHJhbmRvbSBkYXRlLCBubyBtaW4gb3IgbWF4IG5lZWRlZFxuXHRcdFx0XHRcdGNvbmZpZy5kYXRldGltZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAocGFyYW1ldGVyLmZha2VyU3ViQ2F0ZWdvcnkgPT09ICdlbWFpbCcpIHtcblx0XHRcdFx0Y29uZmlnLmVtYWlsID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAocGFyYW1ldGVyLmZha2VyU3ViQ2F0ZWdvcnkgPT09ICd1cmwnKSB7XG5cdFx0XHRcdGNvbmZpZy51cmwgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmIChpc1N0cmluZyAmJiBwYXJhbWV0ZXIuZmFrZXJTdWJDYXRlZ29yeSA9PT0gJ2FycmF5RWxlbWVudCcpIHtcblx0XHRcdFx0Ly8gV2UgaGF2ZSB0byBjaGVjayBpZiBhcnJheSBpcyBhbiBhcnJheSBvZiBzdHJpbmdzIHNpbmNlIHZhbGlkYXRlLmpzIGRvZXNuJ3Qgc3VwcG9ydFxuXHRcdFx0XHQvLyBuZXN0ZWQgb2JqZWN0cy4gVE9ETzogd3JpdGUgYSB2YWxpZGF0b3IgdGhhdCBzdXBwb3J0cyBkZWVwRXF1YWwgb2YgbmVzdGVkIG9iamVjdHMuXG5cdFx0XHRcdGNvbmZpZy5pbmNsdXNpb24gPSBwYXJhbWV0ZXIuZmFrZXJQYXJhbXMuanNvbjtcblx0XHRcdH0gZWxzZSBpZiAoaXNCb29sZWFuKSB7XG5cdFx0XHRcdGNvbmZpZy5ib29sZWFuID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAocGFyYW1ldGVyLmZha2VyU3ViQ2F0ZWdvcnkgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNvbmZpZy5udW1lcmljYWxpdHkgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjb25maWc7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgUmVzb3VyY2VVdGlscygpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9iYWNrZW5kL1Jlc291cmNlVXRpbHMuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ }

})